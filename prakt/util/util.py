

def Min(sequence):
    """
    Args:
      sequence (list(tuples)): A list of tuples where the first item of a tuple is the value of the item
                               and second item is the case identifier
    
    Returns:
      list(tuple): A list of tuples with minimum value and the corresponding case identifier
    """
    min_value = min(sequence, key=lambda x: x[0])[0]
    return [t for t in sequence if t[0] == min_value]


def Max(sequence):
    """
    Args:
      sequence (list(tuples)): A list of tuples where the first item of a tuple is the value of the item
                               and second item is the case identifier
    
    Returns:
      tuple: A list of tuples with maximum value and the corresponding case identifier
    """
    max_value = max(sequence, key=lambda x: x[0])[0]
    return [t for t in sequence if t[0] == max_value]


def compute_traceback(start, all=False):
    """Compute the alignment(s) generated by tracing back in the dp matrix

    Args:
        start (cell): the cell from where to start dfs
        all (boolean): Indicates if all optimal alignments should get returned
                        or just one
    
    Return:
        list(list(Cell)) : A list containing all paths of integers which yield an optimal alignment
                           The first element is the bottom right case.
                           The last element is the 1 1 case.
    """
    tracebacks = compute_traceback_dfs(start)
    if all:
        return tracebacks
    return [tracebacks[0]]


def compute_traceback_dfs(current_cell, current_path=[]):
    """Recursively creates the list of all tracebacks.

    Initial call: Bottom right cell in the dynamic programming matrix

    Args:
        current_cell (Cell) : The cell where we are currently in the traceback
        current_path (list(int)) : List of cases that are on the traceback path
                                   first element is case in bottom right cell
                                   last element is the previous cases
    """
    # base case: leaf
    if not current_cell.pre:
        return [current_path]
    # recursive case: inner node
    tracebacks = []
    for pre in current_cell.pre:
        # add the case information to the path, current implementation has runtime O(n^2) in worst case
        # even for single optimal alignment
        tracebacks.extend(compute_traceback_dfs(pre[0], current_path + [pre[1]]))
    return tracebacks
